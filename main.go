package main

import (
	"encoding/json"
	"fmt"
	"net/http"
	"time"

	"istio.io/api/mixer/v1/config/client"
	"istio.io/istio/mixer/adapter/memquota/config"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/runtime"
	"k8s.io/apimachinery/pkg/runtime/schema"
	"k8s.io/apimachinery/pkg/runtime/serializer"
	"k8s.io/client-go/kubernetes"
	"k8s.io/client-go/rest"
	"k8s.io/client-go/tools/clientcmd"
)

var k8sRestClient *rest.RESTClient
var err error

func main() {
	// vs := &istioNetworkingApi.VirtualService{}
	// vs.Gateways = []string{}
	//
	// // fmt.Println(vs.Gateways)
	// bs, _ := json.MarshalIndent(vs, "", "  ")
	// fmt.Println(string(bs))
	//
	// quota := &config.Params_Quota{}
	// bs, _ = json.MarshalIndent(quota, "", "  ")
	// fmt.Println(string(bs))

	// return

	// creates the in-cluster config
	config, err := rest.InClusterConfig()
	if err != nil {
		config, err = clientcmd.BuildConfigFromFlags("", "/home/lance/.kube/config")
		if err != nil {
			panic(err.Error())
		}
	}

	config.APIPath = "/apis"
	config.GroupVersion = &schema.GroupVersion{
		Group:   "networking.istio.io",
		Version: "v1alpha3",
	}
	config.NegotiatedSerializer = serializer.DirectCodecFactory{CodecFactory: serializer.NewCodecFactory(runtime.NewScheme())}

	go getPodNum(config)

	k8sRestClient, err = rest.RESTClientFor(config)
	if err != nil {
		fmt.Println(err)
		return
	}

	mux := http.NewServeMux()

	mux.HandleFunc("/virtualservices", getVirtualServices)
	mux.HandleFunc("/destinationrules", getDestinationRules)
	mux.HandleFunc("/deployments", getDeployments)
	mux.HandleFunc("/ratelimit", handleRateLimit)

	if err := http.ListenAndServe(":8882", mux); err != nil {
		fmt.Println(err)
	}

}

func handleRateLimit(w http.ResponseWriter, r *http.Request) {
	if r.Method != http.MethodPost {
		w.WriteHeader(http.StatusMethodNotAllowed)
		w.Write([]byte(fmt.Sprintf("Method %s not allowed", r.Method)))
		return
	}
	quotaJsonString := createQuotaJsonString()
	// fmt.Println(quotaJsonString)

	config, err := rest.InClusterConfig()
	if err != nil {
		config, err = clientcmd.BuildConfigFromFlags("", "/home/lance/.kube/config")
		if err != nil {
			// panic(err.Error())
			w.WriteHeader(http.StatusInternalServerError)
			fmt.Fprintf(w, err.Error())
			return
		}
	}

	config.APIPath = "/apis"
	config.GroupVersion = &schema.GroupVersion{
		Group:   "config.istio.io",
		Version: "v1alpha2",
	}
	config.NegotiatedSerializer = serializer.DirectCodecFactory{CodecFactory: serializer.NewCodecFactory(runtime.NewScheme())}

	k8sRestClient, err = rest.RESTClientFor(config)
	if err != nil {
		fmt.Println(err)
		w.WriteHeader(http.StatusInternalServerError)
		fmt.Fprintf(w, err.Error())
		return
	}

	// req := k8sRestClient.Patch(types.JSONPatchType).Name("requestcount")
	// Cannot use 'Get' method to decode the json content, it complaints that 'QuotaList' is not registered
	// This is generated by request.Serilizers.Decoder(which is actually a json serializer: vendor/k8s.io/apimachinery/pkg/runtime/serializer/json/json.go)
	// obj, err := k8sRestClient.Get().Resource("quotas").Namespace("lance-test").Do().Get()
	bs, err := k8sRestClient.Get().Resource("quotas").Namespace("lance-test").Do().Raw()
	if err != nil {
		w.WriteHeader(http.StatusInternalServerError)
		w.Write([]byte(err.Error()))
		fmt.Println(string(bs))
		return
	}
	fmt.Println(string(bs))
	// var obj map[string]interface{}
	// json.Unmarshal(bs, obj)
	// fmt.Println(obj["spec"])

	// req := k8sRestClient.Post()
	// req.SubResource("quotas")
	req := k8sRestClient.Post()
	req.Resource("quotas")
	req.Namespace("lance-test")
	req.Body([]byte(quotaJsonString))
	result := req.Do()
	rawBody, err := result.Raw()
	if err != nil {
		w.WriteHeader(http.StatusInternalServerError)
		fmt.Println(string(rawBody))
		// fmt.Fprintf(w, err.Error())
		w.Write([]byte(err.Error()))
		return
	} else {
		w.Write(rawBody)
		w.WriteHeader(http.StatusCreated)
		return
	}
}

var SERVICE_NAME string = "calculator"

func createMemQuota() *config.Params_Quota {
	paramsQuota := &config.Params_Quota{
		Name:          fmt.Sprintf("memquota-%s", SERVICE_NAME),
		MaxAmount:     1000,
		ValidDuration: time.Second,
		Overrides: []config.Params_Override{
			{
				Dimensions: map[string]string{
					"destination":   "ratings",
					"source":        "reviews",
					"sourceVersion": "v3",
				},
				MaxAmount:     1,
				ValidDuration: time.Second * 5,
			},
		},
	}
	return paramsQuota
}

func createQuotaJsonString() string {
	/* Sample:
	   {
	     "apiVersion": "config.istio.io/v1alpha2",
	     "kind": "quota",
	     "metadata": {
	       "clusterName": "",
	       "name": "requestcount",
	       "namespace": "istio-system",
	     },
	     "spec": {
	       "dimensions": {
	         "destination": "destination.labels[\"app\"] | destination.service | \"unknown\"",
	         "destinationVersion": "destination.labels[\"version\"] | \"unknown\"",
	         "source": "source.labels[\"app\"] | source.service | \"unknown\"",
	         "sourceVersion": "source.labels[\"version\"] | \"unknown\""
	       }
	     }
	   }
	*/
	dimensions := map[string]string{
		"destination":        "destination.labels[\"app\"] | destination.service | \"unknown\"",
		"destinationVersion": "destination.labels[\"version\"] | \"unknown\"",
		"source":             "source.labels[\"app\"] | source.service | \"unknown\"",
		"sourceVersion":      "source.labels[\"version\"] | \"unknown\"",
	}

	metadata := map[string]string{
		"name":      "requestcount",
		"namespace": "lance-test",
	}

	quota := map[string]interface{}{
		"apiVersion": "config.istio.io/v1alpha2",
		"kind":       "quota",
		"metadata":   metadata,
		"spec": map[string]interface{}{
			"dimensions": dimensions,
		},
	}

	bs, _ := json.Marshal(&quota)
	return string(bs)
}

func createRule() []*client.QuotaRule {
	quota := &client.Quota{
		Quota:  "",
		Charge: 1,
	}
	quotaRule := &client.QuotaRule{
		Quotas: []*client.Quota{quota},
	}

	return []*client.QuotaRule{quotaRule}
}
func createQuotaSpec(rules []*client.QuotaRule) *client.QuotaSpec {
	quotaSpec := &client.QuotaSpec{
		Rules: rules,
	}

	return quotaSpec
}

func createQuotaSpecBinding() *client.QuotaSpecBinding {
	services := []*client.IstioService{
		{
			Name:      SERVICE_NAME,
			Namespace: "default",
		},
	}
	quotaSpecRefs := []*client.QuotaSpecBinding_QuotaSpecReference{
		{
			Name:      "",
			Namespace: "default",
		},
	}

	return &client.QuotaSpecBinding{
		Services:   services,
		QuotaSpecs: quotaSpecRefs,
	}
}

func getPodNum(config *rest.Config) {
	clientset, err := kubernetes.NewForConfig(config)
	if err != nil {
		fmt.Println(err.Error())
		return
	}
	pods, err := clientset.CoreV1().Pods("").List(metav1.ListOptions{})
	if err != nil {
		fmt.Println(err.Error())
		return
	}
	fmt.Printf("There are %d pods in the cluster\n", len(pods.Items))
}

func getVirtualServices(w http.ResponseWriter, r *http.Request) {

	req := k8sRestClient.Get()
	req.SubResource("virtualservices")
	result := req.Do()
	rawBody, err := result.Raw()
	if err != nil {
		fmt.Println(err)
		w.WriteHeader(http.StatusInternalServerError)
		fmt.Fprintf(w, err.Error())
		return
	} else {
		w.Write(rawBody)
		return
	}

}

func getDeployments(w http.ResponseWriter, r *http.Request) {
	config, err := rest.InClusterConfig()
	if err != nil {
		config, err = clientcmd.BuildConfigFromFlags("", "/home/lance/.kube/config")
		if err != nil {
			panic(err.Error())
		}
	}

	config.APIPath = "/apis"
	config.GroupVersion = &schema.GroupVersion{
		Group:   "apps",
		Version: "v1",
	}
	config.NegotiatedSerializer = serializer.DirectCodecFactory{CodecFactory: serializer.NewCodecFactory(runtime.NewScheme())}

	k8sRestClient, err := rest.RESTClientFor(config)
	if err != nil {
		fmt.Println(err)
		return
	}

	req := k8sRestClient.Get()
	req.SubResource("deployments")
	result := req.Do()
	rawBody, err := result.Raw()
	if err != nil {
		fmt.Println(err)
		w.WriteHeader(http.StatusInternalServerError)
		fmt.Fprintf(w, err.Error())
		return
	} else {
		w.Write(rawBody)
		return
	}
}
func getDestinationRules(w http.ResponseWriter, r *http.Request) {
	req := k8sRestClient.Get()
	req.SubResource("destinationrules")
	result := req.Do()
	rawBody, err := result.Raw()
	if err != nil {
		fmt.Println(err)
		w.WriteHeader(http.StatusInternalServerError)
		fmt.Fprintf(w, err.Error())
		return
	} else {
		w.Write(rawBody)
		return
	}
}
