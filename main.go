package main

import (
	"encoding/json"
	"fmt"
	"net/http"
	"time"

	"github.com/juzhen/k8s-client-test/model"
	"istio.io/api/mixer/v1/config/client"
	"istio.io/istio/mixer/adapter/memquota/config"
	"k8s.io/apimachinery/pkg/api/errors"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/runtime"
	"k8s.io/apimachinery/pkg/runtime/schema"
	"k8s.io/apimachinery/pkg/runtime/serializer"
	"k8s.io/client-go/kubernetes"
	"k8s.io/client-go/rest"
	"k8s.io/client-go/tools/clientcmd"
)

func main() {
	mux := http.NewServeMux()

	mux.HandleFunc("/virtualservices", getVirtualServices)
	mux.HandleFunc("/destinationrules", getDestinationRules)
	mux.HandleFunc("/deployments", getDeployments)
	mux.HandleFunc("/ratelimit", handleRateLimit)

	fmt.Println("listen on port 8882")
	if err := http.ListenAndServe(":8882", mux); err != nil {
		fmt.Println(err)
	}

}

func handleRateLimit(w http.ResponseWriter, r *http.Request) {
	if r.Method != http.MethodPost {
		w.WriteHeader(http.StatusMethodNotAllowed)
		w.Write([]byte(fmt.Sprintf("Method %s not allowed", r.Method)))
		return
	}

	quotaName := "requestcount"
	namespace := "lance-test"
	dimensions := map[string]string{
		"destination":        "destination.labels[\"app\"] | destination.service | \"unknown\"",
		"destinationVersion": "destination.labels[\"version\"] | \"unknown\"",
		"source":             "source.labels[\"app\"] | source.service | \"unknown\"",
		"sourceVersion":      "source.labels[\"version\"] | \"unknown\"",
	}

	if bs, err := createQuota(quotaName+"xx", namespace, dimensions); err != nil {
		w.WriteHeader(http.StatusInternalServerError)
		return
	}

	// Create memquota
	memquotaDimensions := map[string]string{
		"destination":   "ratings",
		"source":        "reviews",
		"sourceVersion": "v3",
	}

	memquotaName := "handler-y"
	if bs, err := createMemQuota(memquotaName, namespace, memquotaDimensions); err != nil {
		w.WriteHeader(http.StatusInternalServerError)
		w.Write([]byte(err.Error()))
		return
	}

	actions := []*model.StructAction{
		{
			Handler:   "handler.memquota",
			Instances: []string{"requestcount.quota"},
		},
	}

	if bs, err := createRule("quota", namespace, actions); err != nil {
		w.WriteHeader(http.StatusInternalServerError)
		w.Write([]byte(err.Error()))
		return
	}

	w.WriteHeader(http.StatusCreated)
}

func createRestClient(apiPath, group, version string) (*rest.RESTClient, error) {
	config, err := rest.InClusterConfig()
	if err != nil {
		config, err = clientcmd.BuildConfigFromFlags("", "/home/lance/.kube/config")
		if err != nil {
			return nil, err
		}
	}

	config.APIPath = apiPath
	config.GroupVersion = &schema.GroupVersion{
		Group:   group,
		Version: version,
	}
	config.NegotiatedSerializer = serializer.DirectCodecFactory{CodecFactory: serializer.NewCodecFactory(runtime.NewScheme())}

	k8sRestClient, err = rest.RESTClientFor(config)
	if err != nil {
		return nil, err
	}
	return k8sRestClient, nil
}

func createQuota(quotaName, namespace string, dimensions map[string]string) ([]byte, error) {
	k8sRestClient, err = createRestClient("/apis", "config.istio.io", "v1alpha2")
	if err != nil {
		return nil, err
	}

	// req := k8sRestClient.Patch(types.JSONPatchType).Name("requestcount")
	// Cannot use 'Get' method to decode the json content, it complaints that 'QuotaList' is not registered
	// This is generated by request.Serilizers.Decoder(which is actually a json serializer: vendor/k8s.io/apimachinery/pkg/runtime/serializer/json/json.go)
	// obj, err := k8sRestClient.Get().Resource("quotas").Namespace("lance-test").Do().Get()
	result := k8sRestClient.Get().Resource("quotas").Namespace(namespace).Name(quotaName).Do()
	// If we have the quota, replace it

	var createReq *rest.Request
	var resultStatusCode int
	result.StatusCode(&resultStatusCode)

	bs, err := result.Raw()
	if err != nil && !errors.IsNotFound(err) {
		return nil, err
	}

	var quota *model.StructQuota

	if resultStatusCode == http.StatusOK {
		e := json.Unmarshal(bs, &quota)
		if e != nil {
			return nil, e
		}
		quota.Spec.Dimensions = dimensions
		createReq = k8sRestClient.Put().Resource("quotas").Namespace(namespace).Name(quotaName)
	} else {
		// Create the quota
		quota = model.Quota(quotaName, namespace, dimensions)
		createReq = k8sRestClient.Post().Resource("quotas").Namespace(namespace).Name(quotaName)
	}

	quotaJsonBytes, _ := json.Marshal(&quota)
	createReq.Body(quotaJsonBytes)
	result = createReq.Do()
	return result.Raw()
}

var SERVICE_NAME string = "calculator"

// func createMemQuota(serviceName, namespace string, dimensions map[string]string) *config.Params_Quota {
func createMemQuota(memquotaName, namespace string, dimensions map[string]string) ([]byte, error) {
	paramsQuota := &config.Params_Quota{
		Name:          fmt.Sprintf("memquota-quota-%s", memquotaName),
		MaxAmount:     1000,
		ValidDuration: time.Second,
		Overrides: []config.Params_Override{
			{
				Dimensions:    dimensions,
				MaxAmount:     1,
				ValidDuration: time.Second * 5,
			},
		},
	}

	restclient, err := createRestClient("apis", "config.istio.io", "v1alpha2")
	result := restclient.Get().Resource("memquotas").Namespace(namespace).Name(memquotaName).Do()

	bs, err := result.Raw()
	var resultStatusCode int
	result.StatusCode(&resultStatusCode)
	if err != nil && !errors.IsNotFound(err) {
		return nil, err
	}

	// If we have the memquota, replace it
	var createReq *rest.Request
	var memquota *model.StructMemQuota

	if resultStatusCode == http.StatusOK {
		e := json.Unmarshal(bs, &memquota)
		if e != nil {
			return nil, e
		}
		memquota.Spec.Quotas = []*config.Params_Quota{paramsQuota}
		createReq = k8sRestClient.Put().Resource("memquotas").Namespace(namespace).Name(memquotaName)
	} else {
		memquota = model.MemQuota(memquotaName, namespace, []*config.Params_Quota{paramsQuota})
		createReq = k8sRestClient.Post().Resource("memquotas").Namespace(namespace).Name(memquotaName)
	}

	memquotaJsonBytes, _ := json.Marshal(&memquota)
	createReq.Body(memquotaJsonBytes)
	result = createReq.Do()
	return result.Raw()
}

func createRule(name, namespace string, actions []*model.StructAction) ([]byte, error) {

	restclient, err := createRestClient("/apis", "config.istio.io", "v1alpha2")
	if err != nil {
		return nil, err
	}

	result := restclient.Get().Resource("rules").Namespace(namespace).Name(name).Do()
	bs, err := result.Raw()
	var resultStatusCode int
	result.StatusCode(&resultStatusCode)

	if err != nil && !errors.IsNotFound(err) {
		return nil, err
	}

	// If we have the quota, replace it
	var createReq *rest.Request
	var rule *model.StructRule

	if resultStatusCode == http.StatusOK {
		e := json.Unmarshal(bs, &rule)
		if e != nil {
			return nil, e
		}
		rule.Spec.Actions = actions
		createReq = k8sRestClient.Put().Resource("rules").Namespace(namespace).Name(name)
	} else {
		// Create the quota
		rule = model.Rule(name, namespace, actions)
		createReq = k8sRestClient.Post().Resource("rules").Namespace(namespace).Name(name)
	}

	ruleJsonBytes, _ := json.Marshal(&rule)
	createReq.Body(ruleJsonBytes)
	result = createReq.Do()
	return result.Raw()
}

func createQuotaJsonObj(quotaName, namespace string, dimensions map[string]string) map[string]interface{} {
	/* Sample:
	   {
	     "apiVersion": "config.istio.io/v1alpha2",
	     "kind": "quota",
	     "metadata": {
	       "clusterName": "",
	       "name": "requestcount",
	       "namespace": "istio-system",
	     },
	     "spec": {
	       "dimensions": {
	         "destination": "destination.labels[\"app\"] | destination.service | \"unknown\"",
	         "destinationVersion": "destination.labels[\"version\"] | \"unknown\"",
	         "source": "source.labels[\"app\"] | source.service | \"unknown\"",
	         "sourceVersion": "source.labels[\"version\"] | \"unknown\""
	       }
	     }
	   }
	*/

	metadata := map[string]string{
		"name":      quotaName,
		"namespace": namespace,
	}

	quota := map[string]interface{}{
		"apiVersion": "config.istio.io/v1alpha2",
		"kind":       "quota",
		"metadata":   metadata,
		"spec": map[string]interface{}{
			"dimensions": dimensions,
		},
	}

	return quota
}

// The instance for the 'rules' field in QuotaSpec
func createQuotaRule() []*client.QuotaRule {
	quota := &client.Quota{
		Quota:  "",
		Charge: 1,
	}
	quotaRule := &client.QuotaRule{
		Quotas: []*client.Quota{quota},
	}

	return []*client.QuotaRule{quotaRule}
}
func createQuotaSpec(rules []*client.QuotaRule) *client.QuotaSpec {
	quotaSpec := &client.QuotaSpec{
		Rules: rules,
	}

	return quotaSpec
}

func createQuotaSpecBinding() *client.QuotaSpecBinding {
	services := []*client.IstioService{
		{
			Name:      SERVICE_NAME,
			Namespace: "default",
		},
	}
	quotaSpecRefs := []*client.QuotaSpecBinding_QuotaSpecReference{
		{
			Name:      "",
			Namespace: "default",
		},
	}

	return &client.QuotaSpecBinding{
		Services:   services,
		QuotaSpecs: quotaSpecRefs,
	}
}

func getPodNum(config *rest.Config) {
	clientset, err := kubernetes.NewForConfig(config)
	if err != nil {
		return
	}
	pods, err := clientset.CoreV1().Pods("").List(metav1.ListOptions{})
	if err != nil {
		return
	}
	fmt.Printf("There are %d pods in the cluster\n", len(pods.Items))
}

func getVirtualServices(w http.ResponseWriter, r *http.Request) {

	req := k8sRestClient.Get()
	req.SubResource("virtualservices")
	result := req.Do()
	rawBody, err := result.Raw()
	if err != nil {
		w.WriteHeader(http.StatusInternalServerError)
		fmt.Fprintf(w, err.Error())
		return
	} else {
		w.Write(rawBody)
		return
	}

}

func getDeployments(w http.ResponseWriter, r *http.Request) {
	config, err := rest.InClusterConfig()
	if err != nil {
		config, err = clientcmd.BuildConfigFromFlags("", "/home/lance/.kube/config")
		if err != nil {
			panic(err.Error())
		}
	}

	config.APIPath = "/apis"
	config.GroupVersion = &schema.GroupVersion{
		Group:   "apps",
		Version: "v1",
	}
	config.NegotiatedSerializer = serializer.DirectCodecFactory{CodecFactory: serializer.NewCodecFactory(runtime.NewScheme())}

	k8sRestClient, err := rest.RESTClientFor(config)
	if err != nil {
		return
	}

	req := k8sRestClient.Get()
	req.SubResource("deployments")
	result := req.Do()
	rawBody, err := result.Raw()
	if err != nil {
		w.WriteHeader(http.StatusInternalServerError)
		fmt.Fprintf(w, err.Error())
		return
	} else {
		w.Write(rawBody)
		return
	}
}
func getDestinationRules(w http.ResponseWriter, r *http.Request) {
	req := k8sRestClient.Get()
	req.SubResource("destinationrules")
	result := req.Do()
	rawBody, err := result.Raw()
	if err != nil {
		w.WriteHeader(http.StatusInternalServerError)
		fmt.Fprintf(w, err.Error())
		return
	} else {
		w.Write(rawBody)
		return
	}
}
